#!/usr/bin/env python3
"""
propose_base.py - Base class for PROPOSE tools

PROPOSE tools generate change proposals without applying them:
  - Generate patch files
  - Document rationale
  - List tests to run
  - Track evidence links
  - Create machine-verifiable proposals

The pattern:
  1. PROPOSE tool generates PROPOSAL.json + PROPOSAL.patch
  2. Human or CI reviews
  3. APPROVAL.json is created (manually or via policy)
  4. APPLY tool applies changes (verifies approval first)

Usage:
    from tools.propose_base import ProposeTool

    class MyProposer(ProposeTool):
        def generate_changes(self):
            # Return list of proposed changes
            pass
"""

import hashlib
import json
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional


@dataclass
class FileChange:
    """A single file change in a proposal."""
    path: str
    action: str  # modify, create, delete, rename
    before_content: Optional[str] = None
    after_content: Optional[str] = None
    before_hash: str = ""
    after_hash: str = ""
    rename_to: Optional[str] = None

    def compute_hashes(self):
        """Compute before/after hashes."""
        if self.before_content:
            self.before_hash = f"sha256:{hashlib.sha256(self.before_content.encode()).hexdigest()}"
        if self.after_content:
            self.after_hash = f"sha256:{hashlib.sha256(self.after_content.encode()).hexdigest()}"


@dataclass
class Proposal:
    """A change proposal generated by a PROPOSE tool."""
    proposal_id: str
    plan_id: str
    task_id: str
    type: str  # patch, create, delete, rename
    title: str
    description: str
    rationale: str
    risk_classification: str  # low, medium, high, critical
    files: list[FileChange] = field(default_factory=list)
    tests_to_run: list[str] = field(default_factory=list)
    evidence_ids: list[str] = field(default_factory=list)
    created_at: str = ""
    status: str = "pending"
    request_hash: str = ""

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

    def compute_request_hash(self) -> str:
        """
        Compute hash of proposal content for approval verification.

        This prevents tampering between proposal and approval.
        """
        content = json.dumps({
            "proposal_id": self.proposal_id,
            "type": self.type,
            "files": [{"path": f.path, "action": f.action, "after_hash": f.after_hash} for f in self.files],
        }, sort_keys=True)
        self.request_hash = f"sha256:{hashlib.sha256(content.encode()).hexdigest()}"
        return self.request_hash

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "proposal_id": self.proposal_id,
            "plan_id": self.plan_id,
            "task_id": self.task_id,
            "type": self.type,
            "title": self.title,
            "description": self.description,
            "rationale": self.rationale,
            "risk_classification": self.risk_classification,
            "created_at": self.created_at,
            "status": self.status,
            "files": [
                {
                    "path": f.path,
                    "action": f.action,
                    "before_hash": f.before_hash,
                    "after_hash": f.after_hash,
                    **({"rename_to": f.rename_to} if f.rename_to else {})
                }
                for f in self.files
            ],
            "tests_to_run": self.tests_to_run,
            "evidence_ids": self.evidence_ids,
            "request_hash": self.request_hash,
        }


class ProposeTool(ABC):
    """
    Base class for PROPOSE tools.

    Subclasses implement generate_changes() to produce file changes.
    """

    TOOL_NAME = "propose_base"
    VERSION = "1.0.0"

    def __init__(
        self,
        project_path: Path,
        run_dir: Path,
        plan_id: str,
        task_id: str,
        evidence_dir: Path = None
    ):
        self.project_path = Path(project_path)
        self.run_dir = Path(run_dir)
        self.plan_id = plan_id
        self.task_id = task_id
        self.evidence_dir = evidence_dir or (run_dir / "proposals")
        self.evidence_dir.mkdir(parents=True, exist_ok=True)

        self.changes: list[FileChange] = []
        self.proposal: Optional[Proposal] = None

    @abstractmethod
    def generate_changes(self) -> list[FileChange]:
        """
        Generate list of proposed file changes.

        Subclasses must implement this to produce changes.
        MUST NOT modify the project - only read and compute.
        """
        pass

    @abstractmethod
    def get_title(self) -> str:
        """Return human-readable title for the proposal."""
        pass

    @abstractmethod
    def get_description(self) -> str:
        """Return detailed description of the changes."""
        pass

    @abstractmethod
    def get_rationale(self) -> str:
        """Return rationale for why changes are needed."""
        pass

    def get_risk_classification(self) -> str:
        """Return risk level: low, medium, high, critical."""
        # Default based on number of files
        if len(self.changes) > 10:
            return "high"
        elif len(self.changes) > 3:
            return "medium"
        return "low"

    def get_tests_to_run(self) -> list[str]:
        """Return list of tests that should run after applying."""
        return []

    def get_evidence_ids(self) -> list[str]:
        """Return evidence IDs that support this proposal."""
        return []

    def generate_proposal(self) -> Proposal:
        """
        Generate complete proposal.

        Returns Proposal object with all metadata.
        """
        # Generate changes
        self.changes = self.generate_changes()

        # Compute hashes
        for change in self.changes:
            change.compute_hashes()

        # Generate proposal ID
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
        proposal_id = f"PROPOSAL-{self.task_id}-{timestamp}"

        # Determine type
        actions = set(c.action for c in self.changes)
        if len(actions) == 1:
            prop_type = list(actions)[0]
        else:
            prop_type = "patch"  # Mixed changes

        # Create proposal
        self.proposal = Proposal(
            proposal_id=proposal_id,
            plan_id=self.plan_id,
            task_id=self.task_id,
            type=prop_type,
            title=self.get_title(),
            description=self.get_description(),
            rationale=self.get_rationale(),
            risk_classification=self.get_risk_classification(),
            files=self.changes,
            tests_to_run=self.get_tests_to_run(),
            evidence_ids=self.get_evidence_ids(),
        )

        # Compute request hash
        self.proposal.compute_request_hash()

        return self.proposal

    def generate_unified_diff(self) -> str:
        """
        Generate unified diff patch from changes.

        Returns patch content as string.
        """
        lines = []
        for change in self.changes:
            if change.action == "modify" and change.before_content and change.after_content:
                lines.append(f"--- a/{change.path}")
                lines.append(f"+++ b/{change.path}")

                # Simple diff (real implementation would use difflib)
                before_lines = change.before_content.splitlines(keepends=True)
                after_lines = change.after_content.splitlines(keepends=True)

                import difflib
                diff = difflib.unified_diff(
                    before_lines,
                    after_lines,
                    fromfile=f"a/{change.path}",
                    tofile=f"b/{change.path}",
                    lineterm=""
                )
                lines.extend(diff)
                lines.append("")

            elif change.action == "create" and change.after_content:
                lines.append(f"--- /dev/null")
                lines.append(f"+++ b/{change.path}")
                lines.append("@@ -0,0 +1 @@")
                for line in change.after_content.splitlines():
                    lines.append(f"+{line}")
                lines.append("")

            elif change.action == "delete":
                lines.append(f"--- a/{change.path}")
                lines.append(f"+++ /dev/null")
                if change.before_content:
                    lines.append("@@ -1 +0,0 @@")
                    for line in change.before_content.splitlines():
                        lines.append(f"-{line}")
                lines.append("")

        return "\n".join(lines)

    def write_artifacts(self) -> dict:
        """
        Write proposal artifacts to evidence directory.

        Returns dict with paths to written files.
        """
        if not self.proposal:
            self.generate_proposal()

        # Write PROPOSAL.json
        proposal_path = self.evidence_dir / f"{self.proposal.proposal_id}.json"
        with open(proposal_path, "w", encoding="utf-8") as f:
            json.dump(self.proposal.to_dict(), f, indent=2)

        # Write PROPOSAL.patch
        patch_content = self.generate_unified_diff()
        patch_path = self.evidence_dir / f"{self.proposal.proposal_id}.patch"
        with open(patch_path, "w", encoding="utf-8") as f:
            f.write(patch_content)

        # Write PROPOSAL.md (human-readable summary)
        md_content = self._generate_markdown_summary()
        md_path = self.evidence_dir / f"{self.proposal.proposal_id}.md"
        with open(md_path, "w", encoding="utf-8") as f:
            f.write(md_content)

        return {
            "proposal_json": str(proposal_path),
            "proposal_patch": str(patch_path),
            "proposal_md": str(md_path),
            "proposal_id": self.proposal.proposal_id,
            "request_hash": self.proposal.request_hash,
        }

    def _generate_markdown_summary(self) -> str:
        """Generate human-readable markdown summary."""
        p = self.proposal
        lines = [
            f"# Proposal: {p.title}",
            "",
            f"**ID:** `{p.proposal_id}`  ",
            f"**Status:** {p.status}  ",
            f"**Risk:** {p.risk_classification}  ",
            f"**Created:** {p.created_at}  ",
            "",
            "## Description",
            "",
            p.description,
            "",
            "## Rationale",
            "",
            p.rationale,
            "",
            "## Files Affected",
            "",
            "| File | Action |",
            "|------|--------|",
        ]

        for f in p.files:
            lines.append(f"| `{f.path}` | {f.action} |")

        if p.tests_to_run:
            lines.extend([
                "",
                "## Tests to Run",
                "",
            ])
            for test in p.tests_to_run:
                lines.append(f"- `{test}`")

        lines.extend([
            "",
            "---",
            "",
            f"**Request Hash:** `{p.request_hash}`  ",
            "*Use this hash to verify approval matches this proposal.*",
        ])

        return "\n".join(lines)

    def run(self) -> dict:
        """
        Execute proposal generation.

        Returns dict with status and artifact paths.
        """
        try:
            self.generate_proposal()
            artifacts = self.write_artifacts()

            return {
                "status": "success",
                "proposal_id": self.proposal.proposal_id,
                "files_affected": len(self.changes),
                "risk": self.proposal.risk_classification,
                "artifacts": artifacts,
                "evidence": [
                    {"type": "file", "path": artifacts["proposal_json"]},
                    {"type": "file", "path": artifacts["proposal_patch"]},
                    {"type": "file", "path": artifacts["proposal_md"]},
                ],
            }
        except Exception as e:
            return {
                "status": "failed",
                "error": str(e),
                "evidence": [],
            }
